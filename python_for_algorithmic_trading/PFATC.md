---
title: Python For Algorithmic Trading
markmap:
    colorFreezeLevel: 2
---

## Preface

- Algorithmic Trading
  - Art of Statistical Models
  - Tools for Competitive Edge
  - Python for Design, Backtest, Deploy Strategies
- Book' Goal
  - Professional Techniques for Non-Professionals
  - Digestible Recipes
  - Strong Foundation in Tools & Techniques
- Author's Expertise
  - Jason Strimple: 20+ Years Algorithmic Trading & Python
  - Taught 1,000+ Students('Getting Started with Python for Quant Finance')
- Python Advantages
  - Accessible & Easy to Learn
  - Thousands o f Powerful Libraries
  - Access Financial Data
  - Perform Complex Calculations
  - Efficient Model Backtesting
- Target Audience
  - Active Traders & Investors
    - Lverage Algorithmic Strategies
    - Acquire & Process Free Market Data(OpenBB)
    - Build Research Environment
  - Python Developers with Market Interest
    - Apply Programming Skills to Finance
    - Bridge Coding & Trading Gap
    - Indetify Alpha Factors, Engineer Signals
    - VectorBT for Walk-Forward Optimization
  - Aspiring Algorithmic Traders
    - Foundational Knowledge & Tools
    - Build Production-Ready Backtests(Zipline)
    - Evaluate Factor Performance
    - Connect & Send Orders(Interactive Brokers API)
    - Delpoy Strategies to Live Environment
- What This Books Cover(Chapters)
  - Chapter 1: Acquire Free Financial Market Data
  - Chapter 2: Analyze and Transform Financial Market Data(pandas)
  - Chapter 3: Visualize Financial Market Data(Matplotlib, Seaborn, Ploty Dash)
  - Chapter 4: Store Financial Market Data
  - Chapter 5: Build Alpha Factors for Stock Portfolio
  - Chapter 6: Vector-Based Backtesting with VectorBT
  - Chapter 7: Event-Based Backtesting Factor Portfolio with Zipline Reloaded
  - Chapter 8: Evaluate Factor Risk and Performance with Alphalens Reloaded
  - Chapter 9: Assess Backtest Risk and Performance Metrics with Pyfolio
  - Chapter 10: Set Up the Interactive Brokers Python API
  - Chapter 11: Manage Orders, Positions, and Portfolio with the IB API
  - Chapter 12: Deploy Strategies to a Live Environment
  - Chapter 13: Advanced Recipes for Market Data and Strategy Management
- Technical Requirements
  - Python 3.10
  - Anaconda Distribution(recommended)
  - OpenBB Platform 4+
  - Pandas 2+
  - PostgresSQL(where necessary)
  - Code Examples: macOS with M2 chip

## Contributors

- skip

## Chapter 1: Acquire Free Financial Market Data

- Data: World's Most Valuable Resouce
- Crucial for Algorithmic Trading : High-Quality, Reliable Data
- Python Libraries for Free Data Acquisition
- OpenBB Platform Addresses Data Collection Challenges
- Data Varies Across Source(Pricing, Adjustments)
- Focus on Mainstream Financial Data(Alternative data excluded)
- Recipes
  - Continuous Futures Data(Nasdaq Data Link)
  - S&P 500 Ratios Data(Nasdaq Data Link)
  - Stock Market Data(OpenBB Platform)
  - Historic Futures Data(OpenBB Platform)
  - Options Market Data(OpenBB Platform)
  - Factor Data(pandas_dtareader)
- Technical Setup
  - Anaconda Distribution Recommended
  - Jupyter Notebook & Python Scipts
  - Conda Package Manager(update, create environment)
  - Install Jupyter Notebook(pip)
  - Install OpenBB Platform(pip install openbb[all])
- Nasdaq Data Link
  - Previously Quandl
  - Access to 600 Futures Contrcts
  - Continuous Futures Data for Long-Term Backtesting
  - S&P 500 Ratios(PE, Shiller PE, Earnings Yield, Real Price)
  - API Key
    - Free Account for Higher API Call Limits
    - Sign up on Nasdaq Data Link Website
  - OpenBB Platform
    - Single Interface for Hundreds of Data Feeds
    - Command-Line Interface(for Manual Research)
    - Python Platform(for Programmatic Access)
    - Free to Use
    - Web-based UI(OpenBB Hub) for Configuration/API Keys
    - Download Stock Data(historical, fundamental)
    - Custom Stock Screeners(Finviz backen)
    - Fecth Historic Furtues Data(individual contracts)
    - Navigate Options Market Data(options chains, histroical, Greeks)
  - pandas_datareader
    - Harnessing Factor Data(Fama-French Factors)
    - Fama-French Three-Factor Model
    - Small Minus Big(SMB)
    - High Minus Low(HML)
    - Rm-Rf(Market Excess Return)
    - Access Data from Many Remote Online Sources

## Chapter 2: Analyze and Transform Financial Market Data(pandas)

- Origin: Wes McKinney at AQR Capital Management(2009)
- Standard Tool for Data Analysis with Python
- Well-suited for Tabular Data
- Integrates with Other Python Libraries
- Capabilities: Missing Data, Reshaping, Merging, Loading Data
- Recipes
  - Padas Index Types
  - Building Pandas Series and DataFrames
  - Manipulating and Transforming DataFrames
  - Examining and Selecting Data from DataFrames
  - Calculating Asset Returns using pandas
  - Measuring the Volatility of a Return Series
  - Generating a Cumulative Return Series
  - Resampling Data for Different Time Frames
  - Addressing Missing Data Issures
  - Applying Custom Functions to Analyze Time Series Data
- Pandas Data Structures
  - Series
    - One-dimensional Labeled Arrary
    - Holds Any Data Type
    - Axis Labels: Index
    - Handles Missing Data(Numpy NaN)
    - Methods for Statistical Functions, String Manipulation, Ploting
  - DataFrame
    - Two-dimensional Data Structure(Spreadsheet-like)
    - Rows and Columns of Different Types
    - Easy Data Manipulation: Aggregation, Slicing, Merging
    - Handles Missing Data Gracefully
- Pandas Index Types
  - Immutable Sequence
  - Used for Indexing and Alignment
  - Fast Loopup & Relational Operations
  - Can Contain Values of Any Type
  - Built-in Methods(sorting, grouping, set operations)
  - Seven Types of Indexes
  - Int64Index(integers)
  - DatatimeIndex(time series data, timezone naive/localized)
  - PeriodIndex(ranges of periods, e.g., quarters)
  - MultiIndex(hierarchical Index, complex data organization)
- DataFrame Manipulation
  - Creating New Columns(aggregates, Booleans, Strings)
  - Concatenating DataFrames(row-wise, column-wise)
  - Pivoting DataFrames(pivot_tables, aggfunc)
  - Grouping Data(groupby, multiple columns, custom fuctions)
  - Joining DataFrames(SQL-like joins, straddle prices example)
- Data Selection
  - head(), tail(), .values, .describe()
  - Selecting Columns (df['col'], df[['col']])
  - Slicing Rows by Index(0:3, not inclusive)
  - loc(label-based indexing, single/range/list of rows/cols)
  - iloc(interger-location-based indexing, single/range/list of rows/cols)
  - Boolean Indexing(conditional selection, query method)
  - Partial String Indexing(datetime strings:'2023', '2023-07')
  - at (fast scalar access)
  - nlargest, nsmallest(top/ bottom N values)
- Calculating Asset Retuns
  - Simple Returns(R_t = (P_t - P_{t-1}/P_{t-1}))
  - Aggregate Across Assets
  - Compound(Log)Returns(r_t=log(P_t/P_{t-1}))
  - Additive Over Time
  - Preferred in Practice(less influenced by extremes, mathematical properties)
  - pct_change() method
  - periods argument(multi-period returns)
  - freq parameter(resample returns)
- Measuring Volatility
  - Key Indicator of Risk
  - Standard Deviation(quantifies dispersion of returns)
  - Higher Std Dev =  More Volatility = Higher Risk
  - Used in Risk-Adjusted Returns(e.g., Sharpe Ratio)
  - Annualizing Volatility(multiply by sqrt(trading_days)e.g.,252 for daily)
  - Rolling Volatility
- Cumulative Return Series
  - Quantifies Total Change in Investment Value
  - Simple Returns:(1 + R_t)*(1+R_{t-1})-1(cumprod)
  - Compound Returns:Sum of Single-Period Returns(cumsum)
  - fillna(0.0) for missing values
- Resampling Data
  - Unsampling(lower to higher frequency)
  - Downsampling(higher to lower frequency)
  - Useful for Aligning Trade & Quote Data, Long-Term Trend Analysis
  - resmaple() method(aggregates data: first, last, mean, ohlc)
  - rule, axis, closed, label, convention, kind, loffset, based, on, level, origin, offset arguments
  - asfreq() method(changes frequency without aggregation)
  - Handles NaN values(backfill, pad, fill_value)
  - Business Day Offset(pd.offset.BDay())
- Addressing Missing Data
  - Common Issue in Financial Data
  - Reason: Market Closures, Data Availability, Delisting, Granularity
  - fillna() method(value, axis, inplace, limit, downcast)
  - bfill()(backfill with next valid observation)
  - ffill()(foward-fill with last valid observation)
  - interpolate() method(linear, polynomial, time, spatial)
- Apply Custom Functions
  - apply() function (transformation beyond standard methods)
  - Accepts anonymous lamba or user-defined functions
  - axis=1 for row-wise application
  - args parameter for extra arguments
  - transform() method(after groupby, returns same shape)
  - Note: apply() can be slow on large DataFrames

## Chapter 3: Visualize Financial Market Data

- First Step: Visualize and Explore Data
- Five Powerful Tools: pandas,Matplotlib, Seaborn, Plotly, Ploty Dash
- Each Tool has Pros and Cons based on Use Case
- Recipes
  - Quickly Visualizing Data using pandas
  - Animating the Evolution of the Yield Curve with Matplotlib
  - Plotting Options Implied Volatility Surfaces with Matplotlib
  - Visualizing Statistical Relationships with Seaborn
  - Creating an Interactive PCA Analytics Dashboard with Ploty Dash
- Pandas Plotting
  - Built-in plotting functionality(Matplotlib backend by default)
  - Line Plot(closing price)
  - Bar Chart(daily returns, styling options)
  - Histogram(returns distribution, bins)
  - Box-and-Whisker Plot(median, quartiles, outliers)
  - Scatter Plot(relationship between two assets)
  - scatter_matrix(pairwise relationships, histograms on diagonal)
  - bootstrap_plot(evaluate variability of a statistic)
- Matplotlib Advanced Plotting
  - Advanced Functionality(3D surfaces, animated charts)
  - Animating Yield Curve Evolution
    - Yield curve: charts bond yields across maturities
    - Typically slopes upward
    - Inverted yield curve often proceedes recession
    - Uses FuncAnimation(initialization, animate function, blitting)
  - Plotting Options Implied Volatility Surfaces
    - Visualizes how IV changes with expiration and strike
    - Important for Market Expectations of Future Volatility
    - Show Skew(IV vs. Strike) and Term Structure(IV vs. expiry)
    - Uses mpl_toolkits.mplot3d.Axes3D.plot_surface
- Searbon Statistical Visualizations
  - Tailor-made for Statistical Relationships
  - Built on Matplotlib, intergrates with pandas
  - Importance for Factor Engineering(creating predictos)
  - Box Plot(summarizing monthly returns)
  - Jointplot(scatter plot + marginal histograms, correlation assessment)
  - Correlation Matrices(heatmap for multiple asset relationships)
- Plotly Dash Interactive Dashboards
  - Framework for Building Interactive Web Apps with Python
  - PCA Analytics Dashboard Example
    - PCA: Dimensionality Reduction(identify latent return drivers)
    - Isolates Statistical Return Drivers('alpha factor')
    - Interactive UI for dates, components, ticker symbols
    - Components: dcc.Input, dcc.DatePickerRange, html.Button
    - Callbacks: update_graphs(connects inputs to outputs)
    - Outputs: Bar Chart(explained variance), Line Chart(cumulative explained variance)

## Chapter 4: Store Financial Market Data

- Local Data: Speed of Access, Reliability, Insulation from Outages
- Cost-Efficiency vs. Cloud Expenses
- Flexibility, Intergration with Reasearch Workflows, Faster Backtsts
- Recipes
  - Storing Data on Disk in CSV Format
  - Storing Data on Disk with SQLite
  - Storing Data in a Networked Postgres Database
  - Storing Data in Ultra-Fast HDF5 Format
- CSV Format
  - Universally Recognized, Simple
  - Favored for Straightforward Import/Export
  - Easily Handled by pandas(to_csv, read_csv)
  - Compatible with other tools(Tableau, PowerBI)
  - Manual Inspection Possible
  - Less Speed/Sophistication than other methods
  - to_csv options:sep, header, na_rep, date_fromat, float_format
  - read_csv options: delimiter, nrows, parse_dates, dtype, skiprows
- PostgreSQL Datavase Server
  - Advanced Open Source Relational Database System
  - Handles Vast Datasets, Intricate Querying
  - Improved Performance over On-Disk Options
  - Popular for Cloud Providers(AWS)
  - Scalability Robustness for High-Frequency Data/Concurrent Access
  - Setup More Involved
  - SQLAlchemy(Python toolkit for DB interaction, ORM)
  - psycopg2(PostgreSQL adpter for Python)
  - create_engine(connect to DB)
  - create_database_and_get_engine(handle DB creation)
- Ultra-Fast HDF5 Format
  - Hierarchical Data Format(HDF4, HDF5)
  - Engineered for Volumious Data Storage & Management
  - Open Source, Accommodates Large, Complex Heterogeneous Datasets
  - Directory-like Structure, Versatile Data Organization
  - Primary Objects: Datasets(multidimentsional arrays), Groups(containers)
  - Python Support: h5py, PyTables
  - pandas.HDFStore(uses PyTables under the hood)
  - Advantages: Fast, Columnar Storage for Numerical Datam Small Memory Footprint
  - Useful for Storing Related Data in Hierarchy(options chains, futures expirations)

## Chapter 5: Build Alpha Factors for Stock Portfolios

- Professional Traders Construct Factor Portfolios to Exploit Market Inefficiencies
- Factors Act as Fundamental Building Blocks of Investing(Persistent Forces)
- Trading Edge: Consistent, Non-Random Inefficiency
- Factor Analysis Steps
  - Identifying Factors
  - Determining Sensitivity of Portfolio to Factors
  - Taking Action(Hedging Undesirable Risk, Incresing Exposure)
- Python Libraries
  - scikit-learn(Principal Component Analysis)
  - Statsmodels(Linear Regression)
  - Zipline Reloaded Pippline API(Prepare for Factor Analysis)
- Recipes
  - Identifying Latent Return Drivers using Principal Component Analysis
  - Finding and Hedging Portfolio Beta using Linear Regression
  - Analyzing Portfolio Sensitivities to the Fama-French Factors
  - Assessing Market Inefficiency based on Volatility
  - Preparing a Factor Ranking Model using Zipline Reloaded Pipelines
- Principal Component Analysis(PCA)
  - Dimensionality Reduction Technique
  - Transforms Original Feartures into Principal Components(max variance)
  - Indentifies & Quantifies Sources of Risk(market, sector, asset-specific)
  - scikit-learn.decomposition.PCA
  - Explained Variance Ratio, Cumulative Explained Variance
  - Factor Returns(transformed original returns)
  - Factor Exposures(asset sensitivity to principal components)
- Finding and Hedging Portfolio Beta(Linear Regression)
  - Traders Seek Specific Risks, Hedge Others
  - Factor Models Explain Asset/Portfolio Returns(Y = α + βX)
  - Beta: Sensitivity of Porforlio Returns to Risk Factor
  - Hedging: Neutralize Broader Market Exposure(short factor)
  - Statsmodels(sm.add_constant, OLS)
  - Alpha: Intercept, Excess Return
  - Information Ratio(Risk-adjusted performance: active_return/tracking_error)
- Analyzing Porfolio Sensitivities(Fama-French Factors)
  - Lower Volatility Stocks Historicallly Outperform Higher Volatility(Market Inefficiency)
  - Forward Returns: Returns of Security in Future Period
  - Spearman Rank Correlation: Relationship between Factor and Forward Returns
  - High Correlation = Predictive Power
  - Parkinson Estimator: Uses high/low prices for more accurate volatility
  - SciPy.stats.spearmanr(rank correlation & p-value)
- Preparing a Factor Ranking Model(Zipline Reloaded Pipelines)
  - Zipline Reloaded: Open Source Python Library for Backtesting
  - Pipeline API
    - Define Factors from Data Columns(bundles)
    - Efficiently Process Large Data, Filter Assets
    - Rank Universe of Stocks
    - Output for Alphalens Library
  - Installation
    - Conda for Intel x86, Dependencies + Pip for Apple Silicon
    - Free Nasdaq Data Link Bundle(3000 stocks, through 2018)
    - Custom Momentum Factor(252-day windows)
    - SimplePipelineEngine(loader, asset_finder)
    - AverageDollarVolume(screen for liquidity)
    - Built-in Factor Classes: ExponentialWeightedMovingAverage, BollingerBands, VWAP, AnnualizedVolatility, MaxDrawdown

## Chapter 6: Vector-Based Backtesting  with VectorBT

- Next Phase of Workflow: Backtesting
- Quick Iteration Through Ideas is Critical
- VectorBT: High-Performance, Vector-Based Backtesting Framework
- Efficient Evaluation by Processing Entire Time-Series Data Arrays at Once
- Significantly Speeds Up Backtesting Operations
- Highly Customizable, Fine-Tune Parameters, Assess Multiple Strategies
- Built on pandas, NumPy, Numba(JIT compiler for speed)
- Recipes
  - Building Technical Strategies with VectorBT
  - Conducting Walk-Forward Optimization VectorBT
  - Optimizing the SuperTrend Strategy with VectorBT Pro
- Building Techinical Strategies
  - Simple Moving Average Crossover Strategy(Hello World)
  - vbt.YFData.download(built-in data downloader)
  - vbt.MA.run(moving average indicator)
  - ma_crossed_above, ma_crossed_below(entry/exit signal)
  - vbt.Portfolio.from_holding(simple holding strategy comparison)
  - Split Testing(vbt.range_split for multi-panel data)
  - Trading Statistics(pf.orders.stats)
  - Performance Metrics(pf.sharpe_ratio)
- Conducting Walk-Forward Optimization
  - Addresses Curve-Fitting in Strategy Development
  - Divides Dataset into In-Sample(optimization) and Out-of-Sample(validation)Periods
  - Repeated('walked forward') Through Entire Dataset
  - Assesses Strategy Robustness and Future Performance
  - Computationally Intensive, but More Rigorous
  - vbt.rolling_split(splits into rolling in-sample/out-of-sample periods)
  - Simulate all parameter combinations(maximize Sharpe Ratio)
  - Scipy.stas.ttest_ind(assess statistical significance of overfitting)
- Optimizing SuperTrend Strategy with VectorBT Pro
  - SuperTrend Indicator: Trend-following, identifies momentum direction
  - Constructed using Average True Range(ATR) and Multiplier
  - Signals: Price above SuperTrend(uptrend, buy), Price below SuperTrend(downtrend, sell)
  - VectorBT Pro
    - Full-featured Version of VectorBT
    - Enhancements: Data from Nasdaq Data Link, AlphaVantage, Polygon
    - Synthetic Data Generators, Multi-threading, Stop Laddering, Time Stops
    - Portfolio Optimization(RiskFolio-Lib, PyPortfolioOpt)
    - Custom Indicator using TA-Lib and Numba(JIT compilation @njit)
  - Multi-threaded Data Downloading(vbt.YFData.pull)
  - Indicator Factory Class(vbt.IF) to convert functions to indicators
  - Heatmap(visualize parameter hotspots/max Sharpe ratio)

## Chapter 7: Event-Based Backtesting Factor Portfolios with Zipline Reloaded

- Event-Driven Backtesting Framework
- Processes Market Events Sequentially(Realistic Modeling of Execution/Slippage)
- Accounts for Temporal Sequence of Market Events
- Suitable for Complex Strategies(conditional orders, asset interactions)
- Slower than Vector-Based, but Better Simulates Market Dynamics
- Helpful for Path-Dependent Strategies
- Well suited for Large Universe & Complex Portfolio Construction
- Pipeline API: High-Efficiency Computation of Factors
- Results Analyzed with other Zipline Reloaded Ecosystem Tools
- Recipes
  - Backtesting a Momentum Factor Strategy with Zipline Reloaded
  - Exploring a Mean Reversion Strategy with Zipline Reloaded
- Techinical Requirements
  - Install depends on OS(conda for Intel x86, Homebrew + conda/pip for Apple Silicon)
  - Free Nasdaq Data Link Bundle(3,000 stocks through 2018)
- Backtesting Momentum Factor Strategy
  - Custom Factor computes momentum score(252-day window)
  - Zipline Reloaded Framework Intergration
  - Inspect Strategy Performance
  - Nasdaq Data Link API Key(Environment Variable)
  - Key Zipline Features
    - Data and Time Rules(schedule_function)
      - Pipeline API(attach_pipeline, pipeline_output)
    - Custom Factors(MomentumFactor, AverageDollarVolume)
    - Commission and Slippage Models(set_commission, set_slippage)
    - Record(data for output DataFrame)
    - Order Target Percent(order_target_percent)
    - get_open_orders, get_datetime, can_trade
  - before_trading_start(hook for pipeline output)
  - initialize(run when backtest starts, shedules rebalance)
  - rebalance(logic to bug/short top/bottom N stocks)
  - exec_trades(abstracted order execution)
  - run_algorithm(starts backtest, outputs Dataframe)
  - Output DataFrame(trading, risk, performance statistics)
  - Inspect Key Outputs(cumulative returns, daily returns histogram, rolling Sharpe ratio)
  
## Chapter 8: Evaluate Factor Risk and Performance with Alphalens Reloaded

- Factor Investing: Assets chosen based on attributes/factors for higher returns
- Differs from Traditional Strategies(asset classes)
- Systematic Identification and Harnessing of Factors
- Enhance Portfolio Diversification & Potential Returns(does not eliminate risk)
- Alphalens Reloaded: Library for Performance Analysis of Predictive Alpha Factors
- Assesses Quality of Signals to Predict Future Returns
- Integrates with Zipline Reloaded(use backtest output)
- Provides Tear Sheet(cumulative returns, turnover, information coefficients)
- Recipes
  - Preparing Backtest Results
  - Evaluating the Information Coefficient
  - Examining Factor Return Performance
  - Evaluating Factor Turnover
- Preparing Backtest Results
  - Manipulate Zipline Output for Alphalens Reloaded
  - pandas.read_pickle(deserialize backtest output)
  - Construct Prices DataFrame(symbols in columns, dates in rows)
  - Convert Zipline Equity Objects to Strings
  - Normalize Timestamps to Midnight
  - Construct Factor Data Series(MultiIndex: date, symbol, factor rank)
  - alphalens.utils.get_clean_factor_and_forward_returns(create MultiIndex DataFrame for analysis)
  - Parameters: factor, prices, periods(5,10,21,63 days)
  - Results: DataFrame with forward returns, factor values, factor quantiles
- Evaluating the Information Coefficient(IC)
  - Fundamental Metric in Quantitative Portfolio Construction
  - Gauges Predictive Power of Forecast Relative to Future Returns
  - Uses Spearman Rank Correlation(non-parametric, monotonic relationship)
  - IC Range: -1 to 1(Positive: predictive, Near Zero: no capacitym, Negative: inverse)
  - Origins: Jack L.Treynor(1960s), Fischer Black(1970s)
  - Alphalens Reloaded Functions
  - factor_information_coefficient(IC for each holding period/date)
  - mean_information_coefficient
  - plot_information_table(statistical properties: mean, std dev, t-stat, p-value, skew, kurtosis)
  - plot_ic_ts(IC evolution through time)
  - IC Decay(how quickly correlation diminished)
  - Resample Daily IC to Quarterly Mean
- Examining Factor Return Performance
  - Factor Performance: Returns from Factor-Based Portfolio
  - Long Assets with High Factor Values, Short with Low
  - Primary Objective: Assess Factor Performance, Premium over Benchmark
  - Alphalens Reloaded Functions
  - factor_returns(period-wise returns, factor-weighted, by_asset=True)
  - factor_cumulative_returns(cumulative returns, compare equal-weighted)
  - mean_return_by_quantile(mean returns for factor quantiles)
  - compute_mean_returns_spread(difference in mean returns between upper/lower quantiles)
  - factor_alpha_beta(calculate alpha and beta)
- Evaluating Factor Turnover
  - Turnover: Quantifies Frequency of Assets Bought/Sold to Rebalance Quantiles
  - High Tunrover: Signals Not Persistent, Higher Trading Costs
  - Low Turnover: More Stable Signals
  - Analyze at Quantile Level(stability of rankings)
  - Alphalens Reloaded Functions
  - quantile_turunover(proportion of assets not in quantile in previous period)
  - factor_rank_autocorrelation(autocorrelation of daily Spearman rank correlations)
  - plot_factor_rank_auto_correlation(visualize autocorrelation change)

## Chapter 9: Assess Backtest Risk and Performance Metrics with Pyfolio

- No Single Metric Tells Entire Story(Shape Ratio, Max Drawdown insufficient)
- Composite View(Multiple Metrics) for Nuanced Understanding
- Visualizing Metrics Over Time Captures Strategy Dynamics
- Pyfolio Reloaded(pyfolio): Risk and Performance Analysis Library
- Part of Zipline Reloaded Ecosystem
- Takes Zipline Output to Build Robust Suite of Metrics
- Define Most Important Metrics for Backtest Assessment
- Recipes
  - Preparing Zipline Backtest Results for Pyfolio Reloaded
  - Generating Strategy Performance and Return Analytics
  - Building a Drawdown and Rolling Risk Analysis
  - Analyzing Strategy Holdings, Leverage, Exposure, and Sector Allocations
  - Breaking Down Strategy Performance to Trade Level
- Preparing Backtest Results
  - Data Preprocessing Required for Pyfolio
  - pf.utils.extract_rets_pos_txn_from_zipline(helper function)
  - Extracts returns, positions, transations DataFrames
  - Replace Zipline Equity Objects with String Representations
  - Build Symbol-to-Sector Mapping(OpenBB Platform screener)
  - Accquire Benchmark Data(SPY ETF)
  - Sector Information: Crucial for Understanding Return Source, Risk Management, Diversification
- Generating Strategy Performance and Return Analytics
  - Evaluate Effectiveness of Trading Algorithms
  - Return Analysis(Equity Curves, Return Distributions)
  - Temporal Analyses(Monthly/Annual Return)
  - Compare Against Benchmark(isolate alpha)
  - Pyfolio Plotting Functions
  - plot_rolling_returns(equity curve vs. benchmark)
  - plot_perf_stats(distribution of KPIs)
  - plot_monthly_returns_heatmap
  - plot_annual_returns
  - plot_month_returns_dist(histogram)
  - plot_returns(daily returns line plot)
  - plot_returns_quantiles(box plot of daily, weekly, monthly returns quantiles)
- Building Drawdown and Rolling Risk Analysis
  - Risk Metrics Quantify & Manage Uncertainty
  - Insights into Volatility, Drawdown, Adverse Conditions
  - Pyfolio Plotting Functions
  - plot_drawdown_periods(top 10 drawdowns, equity curve shading)
  - plot_drawdown_underwater(visualize drawdown amounts)
  - show_worst_drawdown_periods(table of top five drawdowns)
  - plot_rolling_volatility(3-month rolling volatility vs. benchmark)
  - plot_rolling_sharpe(3-month rolling Sharpe ratio vs. benchmar)
- Analyzing Strategy Holdings, Leverage, Exposure, and Sector Allocations
  - Holdings: Diversification & Concentration Risks
  - Leverage: Excessive Borrowing Amplifies Losses
  - Sector Allocation: Diversification across Industries
  - Pyfolio Plotting Functions
  - plot_holdings(daily, monthly avg, overall avvg)
  - plot_long_short_holdings(number of long/short positions)
  - plot_gross_levrage
  - plot_expossures(long, short, net exposure)
  - show_and_plot_top_positions(table/chart of max % allocation for top 10 holdings)
  - get_sector_exposures, plot_sector_allocations(strategy sector allocation over time)
- Breaking Down Strategy Performance to Trade Level
  - Granular Insights into Strategy Returns Composition
  - Identify Specific Trades Contributing Disproportionately to Risk/Returns
  - Optimize Trade Execution, Entry/Exit Criteria, Asset Class
  - pf.round_tips.extract_round_trips(identify opening/closing transactions for same asset)
  - pf.round_trips.print_round_trip_stats(summary statistics:percent profitable, winning/losing trades, profit factor, avg winning trade)
  - pf.plotting.plot_round_trip_lifetimes(duration of each round trip, per asset)
  - Aggregate by Sector(using sector_map)

## Chapter 10: Set Up the Interactive Brokers Python API

- Deploy Algorithmic Trading Strategies to Live/Paper Trading Environment
- TWS(Trader Workstation): Advanced Trading Platform
- Alternatives: Alpaca, Think Or Swim, Tasty Trade, Tradier
- TWS Features
  - Robust Risk Management Tools
  - Unparalleled Global Market Access(135 markets, 33 countries)
  - Paper Trading Functionality(risk-free testing)
  - API Intergration(Automate Strategies with Python)
- IB API Concepts
  - Asynchronous Model(non-blocking, requests+callbacks)
  - Request-Callback Pattern(EClient sends reqquest, EWrapper handles response)
  - Inheritance(child class acquires parent properties/methods)
  - Overridng(child class provides specific implementation for parent method)
- Recipes
  - Building an Algorithmic Trading App
  - Creating a Contract Object with the IB API
  - Creating an Order Object with the IB API
  - Fetching Historical Market Data
  - Getting a Market Data Snapshot
  - Streaming Live Tick Data
  - Storing Live Tick Data in a Local SQL Database
- Building an Algorithmic Trading App
  - Reusable Code(connection, orders, data download)
  - Install TWS & IB API
  - TWS Configuration(Enable ActiveX/Socket Clients, Allow localhost, Note Socket Port)
  - IBClient(inherits EClient, sends requests)
  - IBWrapper(inherits EWrapper, handles callbacks)
  - IBApp(inherits IBWrapper, IBClient; initializes connection, runs in separate thread)
- Creating a Contract Object
  - IB Contract: All info for IB to identify instrument
  - Represent Broad Spectrum of Instruments(stocks, options, futures)
  - Key Attributes: symbol, secType, expiry, strike, right, multiplier, exchange, currency, conId
  - Custom Functions: future(), stock(), option()
  - reqContractDetails(get contract detail, including conId)
- Creating an Order Object
  - Contains all info for IB to place orders
  - Dozens of Order Types(market, limit, stop, algorithms)
  - Key Attributes: orderId, action, totalQuantity, orderType, LmtPrice, auxPrice, tif, outsideRTH, account
  - Custom FunctionL market(), limit(), stop()
- Fetching Historical Market Data
  - Asynchronous Process(non-blocking, event-driven)
  - reqHistoricalData(sends request, parameters:contract,duration,bar size, data type)
  - historicalData(callback, processes each bar asynchronously)
  - pandas.DataFrame for data storage
  - get_historical_data_for_many(request for multiple contracts)
- Getting a Market Data Snapshot
  - Current Market Price(e.g., for portfolio target calculations)
  - Tick Types(last trade price, volume, bid/asl)
  - reqMktData(requests market data)
  - tickPrice(callback, handles specific tick types)
- Streaming Live Market Data
  - Tick-by-Tick Data(real-time, granular, Time & Sales window equivalent)
  - reqTickByData(requests real-time tick-by-tick data)
  - Tick Dataclass(Python dataclass for market data ticks)
  - tickByTickBidAsk(callback for BidAsk tick type)
  - Python Generator(yields Tick objects)
  - stop_streaming_data(cancel tick data request)
- Storing Live Tick Data in Local SQL Database
  - Extend Chapter 4's SQLite Recipes
  - Move Tick Dataclass & TRADE_BAR_PROPERTIES to utils.py
  - IBApp.connection(property, creates SQLite connection)
  - IBApp.create_table(creates bid_ask_data table)
  - IBApp.stream_to_sqlite(stores tick data for specified duration)
  - DB Browser for SQLite(inspect data)

## Chapter 11: Manage Orders, Positions, and Portfolios with the IB API

- Efficient Management of Orders, Positions, Portfolio Data is Critical
- Managing Orders: Execute New, Cancel Exitsting, Update Orders
- Managing Positions: Monitor Live PnL, Informed Decisions
- Portfolio Data: Real-time Risk Statistics
- IB API Request-Callback Pattern for ALL Management Aspects
- Submit & Modify Orders, Obtain Key Portfolio Details, Compute PnL
- Recipes
  - Executing Orders with the IB API
  - Managing Orders Once They're Placed
  - Getting Details About Your Portfolio
  - Inspecting Portfolio Profit and Loss
  - Computing Portfolio Profit and Loss
- Executing Orders
  - nextValidOrderId: Unique Identifier for Each Other
  - Used to Preserve Order Untegrity, Prevent Overlap
  - Server Provides Initial ID, Client Increments for New Orders
  - IB Wrapper Overrides
    - nextValidId(captures initial order_id)
    - orderStatus(updates on order status)
    - openOrder(info on submitted, unexecuted orders)
    - execDetails(detailed execution info)
  - IBClient.send_order(accepts contract/order, places order, increments ID)
  - placeOrder(IB API method)
- Managing Orders
  - Canceling Orders(no longer wanted, market conditions change)
  - Updating Orders(change quantity, limit price, stop price)
  - IB Reconmmends only changing price, size, ETF
  - Easier to Cancel & Re-enter with Updated Parameters
  - IBClient.cancel_all_orders(reqGlobalCancel)
  - IBClient.cancel_order_by_id(cancelOrder)
  - IBClient.update_order(cancels existing, sends new)
- Getting Portfolio Details
  - Comprehensive Snapshot(157 different values)
  - Account Values(updateAccountValue callback)
  - Categorized by Commodities(-C), Securities(-S), Totals(no suffix)
  - IBWrapper.account_values(dictionary to store data)
  - IBWrapper.updateAccountValue(callback)
  - IBClient.get_account_values(reqAccountUpdates, returns dictionary or specific key)
  - Common Values: AvailableFunds, Buying Power, CashBalance, NetLiquidation, etc.
- Inspecting Positions and Position Details
  - Position Size, Market Prize, Value, Average Cost, PnL
  - Comprehensive View of Holdings
  - IBWrapper.positions(dictionary to store data)
  - IBWrapper.updatePortfolio(callback triggered by reqAccountUpdates)
  - IBClient.get_positions(triggers callback, returns dictionary)
- Computing Portfolio Profit and Loss
  - Aggregate Daily PnL, Total Unrealized PnL, Total Realized PnL
  - Unlock Suite of Risk Metrics
  - IBWrapper.account_pnl(dictionary to store data)
  - IBWrapper.pnl(callback for PnL data)
  - IBClient.get_pnl(reqPnL, returns PnL dictionary)
  - Unrealized PnL(potential gain/loss on open investment)
  - Realized PnL(gain/loss on sold asset)

## Chapter 12: Deploy Strategies to a Live Environment
  
- Critical Pieces: Risk/Performance Metrics, Sophisticated Order Strategies
- empyrical-reloaded: Generates Statistics Based on Portfolio Returns
- Used for Performance/Risk Analystics(behind Pyfolio Reloaded)
- Calculate KPIs: Sharpe, Sortino, Max Drawdown(real-time portfolio data)
- Asynchronous Code Execution(threads) for PnL calculations
- Finalize Position Managemet Code(target orders: contracts, value, percent)
- Unlocks Portfolio-Based Strategies
- Recipes
  - Calculating Real-Time Key Performance and Risk Indicators
  - Sending Orders Based on Portfolio Targets
  - Deploying a Monthly Factor Portfolio Strategy
  - Deploying an Options Combo Strategy
  - Deploying an Intraday Multi-Asset Mean Reversion Strategy
- Calculating Real-Time Performance and Risk Indicators
  - Compare Live Performance to Backtests
  - Immediate Feedback, Adjustments for Volatility
  - Continuously Monitor Drawdowns, Volatility, Value and Risk
  - empyrical-reloaded(install with pip)
  - IB API no direct portfolio returns(build custom method)
  - Continuous PnL Requests(on seperate thread for independence)
  - IBClient.get_streaming_pnl(periodically requests PnL)
  - IBClient.get_sreaming_returns(compute periodic returns, updates self.portfolio_returns)
  - IBApp Properties(empyrical-reloaded based)
    - cumulative_returns
    - max_drawdown
    - volatility(sample std dev, not annualized for intraday)
    - omega_ratio
    - sharpe_ratio(custom calculation for intraday)
    - cvar(conditional value at risk, percentage & monetary value)
- Sending Orders Based on Portfolio Targets
  - Flexibility to Submit Orders(combining real-time positions/net liquidation)
  - Dynamically Adjust Positions to Qauntity/Value Tartgets
  - Calculate Order Sizes as Percentage of Portfolio
  - Results in Responsive Trading System
  - IBClient Order Methods(under send_order)
  - order_value(fixed monetart amount)
  - order_target_quantity(adjust to target number of contracts)
  - order_percent(order specified percent of portfolio value)
  - order_target_value(adjust to target dollar value)
  - order_target_percent(adjust to target percent of portfolio value)
- Deploying a Monthhly Factor Portfolio Strategy
  - Integrate Momentum Factor(from Chapter5)into Trading App
  - Downloads & Process Premium U.S. Equities Data(20000 stocks)
  - Build Factor Portfolios with Entire Universe of Equities
  - Periodic Rebalancing(monthly, after market hours)
  - Acquires Latest Price Data, Computes Momentum Factor
  - Identifies Top(Long) and Bottom(Short) Momentum Stocks
  - Execute Orders with Target Percentage Allocation
  - Paid Subscription: QuoteMedia's End of Day US Stock Prices(Nasdaq Data Link)
  - Custom Zipline Reloaded Exetension for Ingestion
  - Momentum Factor(CustomFactor)
  - make_pipeline(creates Pipeline for asset selection)
  - Load Extension, Ingest Bundle, Load Bundle Data
  - SimplePipelineEngine(loader, asset_finder)
  - Run Pipeline, Clean DataFrame
  - Query Long/Short Positions
  - Equal-Weight Allocation
  - Loop Through Longs/Shorts, Order Target Percent
  - Optional: Add AverageDollarVolume Screen for Liquidity
- Deploying an Options Combo Strategy
  - Options: Non-Linear Instruments, Multidimensional Value
  - Profit from Range of Outcomes
  - Straddle Strategy: Buy Call & Put(same strike/expiry), Bet on Volatility
  - Premium Collection: Short Iron Condor(sell call/put spread), Bet on Low Volatility
  - Model Options Trades in TWS Strategy Builder
  - Python Implementation(combo_leg, spread functions for multi-leg orders)
  - reqContractDetails(to get conId for combo_leg)
  - Long Strangle Example(long call, long put, different strikes)
  - Order market combo(send market order for strangle)
- Deploying an Intraday Multi-Asset Mean Reversion Strategy
  - Relative Value Strategy: Crack Spread for Refiner Stocks
  - Crack Spread: Price differential between crude oil and refined products
  - Strategy: 1 HO, 2RB, -3 CL (Heating Oil, RBOB Gasoline, Light Sweet Crude Oil)
  - Economic Rationale: Refiner stocks benefit from widening creack spread
  - Strategy: Identify widening crack spread, refiner stock hasn't reacted -> Go long PSX
  - Continuous Loop(through trading day)
  - Download Historical Data(1-minute bars over last week)
  - Compute 1:2:3 Crack Spread
  - Normalize Crack Spread and Refiner Stock(rolling z-score)
  - Trading Signal(z-socre, standard deviation threshold)

## Chapter 13: Advanced Recipes for Market Data and Strategy Management

- Streaming Real-Time Options Data with ThetaData
- Using the ArcticDB DataFrame Database for Tick Storage
- Triggering Real-Time Risk Limit Alerts
- Storing Trade Execution Detials in a SQL Database
